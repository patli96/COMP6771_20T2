Session: 20T2
Assignment: ass1  Submission ID: 5180847


Your submission has been marked. + /usr/bin/less -m /import/reed/2/z5180847/cs6771.ass1.mrk

!!section banner
#######    #     #####    ###    #####  #       #######
#         ##    #     #  #   #  #     # #    #  #    #
#        # #    #     # # #   # #     # #    #      #
 #####     #     #####  #  #  #  #####  #######    #
      #    #    #     # #   # # #     #      #    #
#     #    #    #     #  #   #  #     #      #    #
 #####   #####   #####    ###    #####       #    #

5180847 Li, Patrick                             8543   COMPAS COMPCS

Submissions:-

S 0     Fri Jun 19 18:17:27 2020        5180847 fri12a ass1 0:-1

Wed Jun 24 23:14:52 2020                ## bongo00.orchestra.cse.unsw.EDU.AU ##
!!section listing
dos2unix: converting file /tmp/tmp.Vdctzev7xp/source/word_ladder.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 6537 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/source/word_ladder.cpp
===============================================================================

     1  #include "comp6771/word_ladder.hpp"
     2  #include <absl/container/flat_hash_map.h>
     3  #include <algorithm>
     4  #include <iostream>
     5  #include <queue>
     6  #include <string>
     7  #include <vector>
     8
     9  // Write your implementation here
    10  void dfs (std::string const& from,
    11                                          std::string const& to,
    12                      absl::flat_hash_set<std::string> const& lexicon,
    13                      absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
    14                      std::vector<std::vector<std::string>>& result,
    15                      std::vector<std::string> path,
    16                      unsigned long const& path_len);
                                              ^
+ ================================================================= +
+ though nt technically wrong, for primitive types just do the copy +
+ ================================================================= +
    17
    18  namespace word_ladder {
    19
    20      auto generate(std::string const& from,
    21                          std::string const& to,
    22                          absl::flat_hash_set<std::string> const& lexicon)
    23             -> std::vector<std::vector<std::string>>
    24          {
    25              absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>> map;
    26              auto result = std::vector<std::vector<std::string>>();
    27          auto path = std::vector<std::string>();
    28          path.push_back(from);
                                ^
                                + ========================================= +
                                + std::vector::initializer_list constructor +
                                + ========================================= +
    29          unsigned long shortest_path_len = 0;
    30
    31          auto q_start = std::queue<std::string>();
    32          q_start.push(from);
    33
    34          auto q_end = std::queue<std::string>();
    35          q_end.push(to);
    36
    37          auto visited_start = absl::flat_hash_set<std::string>();
    38          auto visited_end = absl::flat_hash_set<std::string>();
    39
    40          unsigned long path_len_start = 0;
    41          unsigned long path_len_end = 0;
    42
    43                  // Bidirectional BFS
    44                  auto flag = 0;
    45          while (!q_start.empty() && !q_end.empty()) {
    46              // get the size of the queue
    47              auto queue_size_start = q_start.size();
    48              auto queue_size_end = q_end.size();
    49
    50              // BFS from the start word
    51              for (unsigned long iter = 0; iter < queue_size_start; ++ iter){
    52                  // pop
    53                      auto current_word = q_start.front();
    54                                  q_start.pop();
    55                  visited_start.insert(current_word);
    56                                  // for loop the word to swap every letter from 'a' to 'z'
    57                                  for (unsigned long letter = 0; letter < current_word.length(); ++ letter){
    58                                          auto next_word = current_word;
    59                                          for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++ swapped_letter){
    60                                                  next_word[letter] = swapped_letter;
    61                                                  if(next_word == current_word){
    62                                                          continue;
    63                                                  }
    64                                                  if (!visited_end.contains(next_word)){
    65                                                          if (!visited_start.contains(next_word) && lexicon.contains(next_word)){
    66                                                                  q_start.push(next_word);
    67
    68                                                                  // insert the next word into map[current_word]
    69                                                                  if (!map.contains(current_word)){
    70                                                                          absl::flat_hash_set<std::string> temp;
    71                                                                          temp.insert(next_word);
                                                                                   ^
                                                          + ====================== +
                                                          + terrible variable name +
                                                          + ====================== +
    72                                                                          map.insert({current_word, temp});
    73                                                                  } else{
    74                                                                          map[current_word].insert(next_word);
    75                                                                  }
                                                                            ^
                                   + ====================================== +
                                   + should be in another function. too big +
                                   + ====================================== +
    76                              }
    77
    78                          } else{
    79                              flag = 1;
                                       ^
                                       + ========================================= +
                                       + type punning dont use an int as a boolean +
                                       + ========================================= +
    80                              break;
    81                          }
    82                      }
    83                      if (flag == 1){
    84                          break;
    85                      }
    86                  }
    87                  if (flag == 1){
    88                      break;
    89                  }
    90              }
    91              path_len_start ++;
    92
    93              if (flag == 1){
    94                  break;
    95              }
    96
    97              // BFS from the end word
    98              for (unsigned long iter = 0; iter < queue_size_end; ++ iter){
    99                  // pop
   100                  auto current_word = q_end.front();
   101                  q_end.pop();
   102                  visited_end.insert(current_word);
   103                  // for loop the word to swap every letter from 'a' to 'z'
   104                  for (unsigned long letter = 0; letter < current_word.length(); ++ letter){
   105                      auto prev_word = current_word;
   106                      for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++ swapped_letter){
   107                          prev_word[letter] = swapped_letter;
   108                          if(prev_word == current_word){
   109                              continue;
   110                          }
   111                          if (!visited_start.contains(prev_word)){
   112                              if (!visited_end.contains(prev_word) && lexicon.contains(prev_word)){
   113                                  q_end.push(prev_word);
   114
   115                                  // insert the current word into map[prev_word]
   116                                  if (!map.contains(prev_word)){
   117                                      absl::flat_hash_set<std::string> temp;
   118                                      temp.insert(current_word);
   119                                      map.insert({prev_word, temp});
   120                                  } else{
   121                                      map[prev_word].insert(current_word);
   122                                  }
   123                              }
   124                          } else{
   125                              flag = 1;
   126                              break;
   127                          }
   128                      }
   129                      if (flag == 1){
   130                          break;
   131                      }
   132                  }
   133                  if (flag == 1){
   134                      break;
   135                  }
   136              }
   137              path_len_end ++;
   138
   139              if (flag == 1){
   140                  break;
   141              }
   142          }
   143
   144          // print an error message if no path is found
   145          if (flag == 0){
   146              std::cout << "No path is found between " << from << " and " << to << std::endl;
   147              return result;
   148          }
                        ^
                        + ====================================================== +
                        + not part of the spec, would have visible side effects. +
                        + ====================================================== +
   149
   150          shortest_path_len = path_len_start + path_len_end - 1;
   151
   152          // search for all the shortest paths by DFS
   153          dfs(from, to, lexicon, map, result, path, shortest_path_len);
   154
   155          // sort the ladders in alphabetical order
   156          std::sort(result.begin(), result.end());
   157
   158          return result;
   159      }
   160  } // namespace word_ladder
   161
   162  void dfs (std::string const& from,
   163                                          std::string const& to,
   164                      absl::flat_hash_set<std::string> const& lexicon,
   165                      absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
   166                      std::vector<std::vector<std::string>>& result,
   167                      std::vector<std::string> path,
   168                      unsigned long const& path_len)
   169          {
   170
   171          if (path.size() != path_len + 1 ){
   172              for (auto const& next_word: map[from]){
   173                  auto next_path = path;
   174                  next_path.push_back(next_word);
   175                  dfs(next_word, to, lexicon, map, result, next_path, path_len);
   176              }
   177          } else{
   178              if (path.back() == to){
   179                  result.push_back(path);
   180              }
   181          }
   182      }

dos2unix: converting file /tmp/tmp.Vdctzev7xp/source/lexicon.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 773 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/source/lexicon.cpp
===============================================================================

     1  // Copyright (c) Christopher Di Bella.
     2  // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
     3  //
     4  #include "comp6771/word_ladder.hpp"
     5
     6  #include <fstream>
     7  #include <stdexcept>
     8  #include <string>
     9
    10  #include "absl/container/flat_hash_set.h"
    11  #include "range/v3/range/conversion.hpp"
    12  #include "range/v3/view/common.hpp"
    13  #include "range/v3/view/istream.hpp"
    14
    15  namespace word_ladder {
    16          auto read_lexicon(std::string const& path) -> absl::flat_hash_set<std::string> {
    17                  auto in = std::ifstream(path.data());
    18                  if (not in) {
    19                          throw std::runtime_error("Unable to open file.");
    20                  }
    21
    22                  auto interim = ranges::istream_view<std::string>(in) | ranges::views::common;
    23                  return absl::flat_hash_set<std::string>(ranges::begin(interim), ranges::end(interim));
    24          }
    25  } // namespace word_ladder

dos2unix: converting file /tmp/tmp.Vdctzev7xp/test/word_ladder/word_ladder_test1.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 1219 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/test/word_ladder/word_ladder_test1.cpp
===============================================================================

     1  //
     2  //  Copyright UNSW Sydney School of Computer Science and Engineering
     3  //
     4  // Licensed under the Apache License, Version 2.0 (the "License");
     5  // you may not use this file except in compliance with the License.
     6  // You may obtain a copy of the License at
     7  //
     8  //   http://www.apache.org/licenses/LICENSE-2.0
     9  //
    10  // Unless required by applicable law or agreed to in writing, software
    11  // distributed under the License is distributed on an "AS IS" BASIS,
    12  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13  // See the License for the specific language governing permissions and
    14  // limitations under the License.
    15  //
    16  #include "comp6771/word_ladder.hpp"
    17
    18  #include <string>
    19  #include <vector>
    20
    21  #include "catch2/catch.hpp"
    22  #include "comp6771/testing/range/contain.hpp"
    23  #include "range/v3/algorithm/any_of.hpp"
    24  #include "range/v3/algorithm/is_sorted.hpp"
    25  #include "range/v3/range/primitives.hpp"
    26
    27  TEST_CASE("at -> it") {
    28          auto const english_lexicon = word_ladder::read_lexicon("./english.txt");
    29          auto const ladders = word_ladder::generate("at", "it", english_lexicon);
    30
    31          CHECK(ranges::size(ladders) == 1);
    32          CHECK(ranges::is_sorted(ladders));
    33
    34          CHECK(ranges::any_of(ladders, testing::contain({"at", "it"})));
    35  }

dos2unix: converting file /tmp/tmp.Vdctzev7xp/test/word_ladder/word_ladder_test_benchmark.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 1141 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/test/word_ladder/word_ladder_test_benchmark.cpp
===============================================================================

     1  //
     2  //  Copyright UNSW Sydney School of Computer Science and Engineering
     3  //
     4  // Licensed under the Apache License, Version 2.0 (the "License");
     5  // you may not use this file except in compliance with the License.
     6  // You may obtain a copy of the License at
     7  //
     8  //   http://www.apache.org/licenses/LICENSE-2.0
     9  //
    10  // Unless required by applicable law or agreed to in writing, software
    11  // distributed under the License is distributed on an "AS IS" BASIS,
    12  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13  // See the License for the specific language governing permissions and
    14  // limitations under the License.
    15  //
    16  #include "comp6771/word_ladder.hpp"
    17
    18  #include <string>
    19  #include <vector>
    20
    21  #include "catch2/catch.hpp"
    22  #include "comp6771/testing/range/contain.hpp"
    23  #include "range/v3/algorithm/any_of.hpp"
    24  #include "range/v3/algorithm/is_sorted.hpp"
    25  #include "range/v3/range/primitives.hpp"
    26
    27  TEST_CASE("atlases -> cabaret") {
    28          auto const english_lexicon = ::word_ladder::read_lexicon("./english.txt");
    29          auto const ladders = ::word_ladder::generate("atlases", "cabaret", english_lexicon);
    30
    31          CHECK(ranges::size(ladders) != 0);
    32  }

dos2unix: converting file /tmp/tmp.Vdctzev7xp/test/word_ladder/tests.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 3596 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/test/word_ladder/tests.cpp
===============================================================================

     1  //
     2  //  Copyright UNSW Sydney School of Computer Science and Engineering
     3  //
     4  // Licensed under the Apache License, Version 2.0 (the "License");
     5  // you may not use this file except in compliance with the License.
     6  // You may obtain a copy of the License at
     7  //
     8  //   http://www.apache.org/licenses/LICENSE-2.0
     9  //
    10  // Unless required by applicable law or agreed to in writing, software
    11  // distributed under the License is distributed on an "AS IS" BASIS,
    12  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13  // See the License for the specific language governing permissions and
    14  // limitations under the License.
    15  //
    16  // This file contains some test cases I created.
                            ^
                            + =============== +
                            + not a rationale +
                            + =============== +
    17  //
    18  #include "comp6771/word_ladder.hpp"
    19
    20  #include <string>
    21  #include <vector>
    22
    23  #include "catch2/catch.hpp"
    24  #include "comp6771/testing/range/contain.hpp"
    25  #include "range/v3/algorithm/any_of.hpp"
    26  #include "range/v3/algorithm/is_sorted.hpp"
    27  #include "range/v3/range/primitives.hpp"
    28
    29
    30  TEST_CASE("work -> play") {
    31          auto const english_lexicon = word_ladder::read_lexicon("./english.txt");
                                                                              ^
                                                 + ========================== +
                                                 + use test-specific lexicons +
                                                 + ========================== +
    32          auto const ladders = word_ladder::generate("work", "play", english_lexicon);
    33
    34          CHECK(ranges::size(ladders) == 12);
    35          CHECK(ranges::is_sorted(ladders));
    36
    37          CHECK(ranges::any_of(ladders, testing::contain({"work", "fork", "form", "foam", "flam", "flay", "play"})));
    38          CHECK(ranges::any_of(ladders, testing::contain({"work", "pork", "perk", "peak", "pean", "plan", "play"})));
    39          CHECK(ranges::any_of(ladders, testing::contain({"work", "pork", "perk", "peak", "peat", "plat", "play"})));
    40          CHECK(ranges::any_of(ladders, testing::contain({"work", "pork", "perk", "pert", "peat", "plat", "play"})));
    41          CHECK(ranges::any_of(ladders, testing::contain({"work", "pork", "porn", "pirn", "pian", "plan", "play"})));
    42          CHECK(ranges::any_of(ladders, testing::contain({"work", "pork", "port", "pert", "peat", "plat", "play"})));
    43          CHECK(ranges::any_of(ladders, testing::contain({"work", "word", "wood", "pood", "plod", "ploy", "play"})));
    44          CHECK(ranges::any_of(ladders, testing::contain({"work", "worm", "form", "foam", "flam", "flay", "play"})));
    45          CHECK(ranges::any_of(ladders, testing::contain({"work", "worn", "porn", "pirn", "pian", "plan", "play"})));
    46          CHECK(ranges::any_of(ladders, testing::contain({"work", "wort", "bort", "boat", "blat", "plat", "play"})));
    47          CHECK(ranges::any_of(ladders, testing::contain({"work", "wort", "port", "pert", "peat", "plat", "play"})));
    48          CHECK(ranges::any_of(ladders, testing::contain({"work", "wort", "wert", "pert", "peat", "plat", "play"})));
    49  }
    50
    51  TEST_CASE("awake -> sleep") {
    52          auto const english_lexicon = word_ladder::read_lexicon("./english.txt");
    53          auto const ladders = word_ladder::generate("awake", "sleep", english_lexicon);
    54
    55          CHECK(ranges::size(ladders) == 2);
    56          CHECK(ranges::is_sorted(ladders));
    57
    58          CHECK(ranges::any_of(ladders, testing::contain({"awake","aware","sware","share","sharn","shawn","shewn","sheen","sheep","sleep"})));
    59          CHECK(ranges::any_of(ladders, testing::contain({"awake","aware","sware","share","shire","shirr","shier","sheer","sheep","sleep"})));
    60  }
    61
    62  TEST_CASE("at -> it") {
    63          auto const english_lexicon = word_ladder::read_lexicon("./word_list1.txt");
    64          auto const ladders = word_ladder::generate("at", "it", english_lexicon);
    65
    66          CHECK(ranges::size(ladders) == 1);
    67          CHECK(ranges::is_sorted(ladders));
    68
    69          CHECK(ranges::any_of(ladders, testing::contain({"at", "it"})));
    70  }
    71
    72  TEST_CASE("apple -> appaa") {
    73          auto const english_lexicon = word_ladder::read_lexicon("./word_list2.txt");
    74          auto const ladders = word_ladder::generate("apple", "appaa", english_lexicon);
    75
    76          CHECK(ranges::size(ladders) == 0);
    77  }
dos2unix: converting file /tmp/tmp.Vdctzev7xp/test/test_main.cpp to Unix format ...

===============================================================================
-rw-r----- 1 cs6771 cs6771 282 Jun 24 23:14 /tmp/tmp.Vdctzev7xp/test/test_main.cpp
===============================================================================

     1  #define CATCH_CONFIG_MAIN
     2  #include "catch2/catch.hpp"
     3
     4  // This file is designed to act as the program entry point. Everything is defined in catch.hpp, so
     5  // we don't need to worry about doing anything other than indicating our interest to use it via the
     6  // CATCH_CONFIG_MAIN macro.

!!section tests
!!section assess
========================================
======= Running Linter =================
========================================
10,16c10,16
< void dfs (std::string const& from,
<                                       std::string const& to,
<                     absl::flat_hash_set<std::string> const& lexicon,
<                     absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
<                     std::vector<std::vector<std::string>>& result,
<                     std::vector<std::string> path,
<                     unsigned long const& path_len);
---
> void dfs(std::string const& from,
>          std::string const& to,
>          absl::flat_hash_set<std::string> const& lexicon,
>          absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
>          std::vector<std::vector<std::string>>& result,
>          std::vector<std::string> path,
>          unsigned long const& path_len);
20,32c20,31
<     auto generate(std::string const& from,
<                       std::string const& to,
<                       absl::flat_hash_set<std::string> const& lexicon)
<          -> std::vector<std::vector<std::string>>
<       {
<           absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>> map;
<           auto result = std::vector<std::vector<std::string>>();
<         auto path = std::vector<std::string>();
<         path.push_back(from);
<         unsigned long shortest_path_len = 0;
<
<         auto q_start = std::queue<std::string>();
<         q_start.push(from);
---
>       auto generate(std::string const& from,
>                     std::string const& to,
>                     absl::flat_hash_set<std::string> const& lexicon)
>          -> std::vector<std::vector<std::string>> {
>               absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>> map;
>               auto result = std::vector<std::vector<std::string>>();
>               auto path = std::vector<std::string>();
>               path.push_back(from);
>               unsigned long shortest_path_len = 0;
>
>               auto q_start = std::queue<std::string>();
>               q_start.push(from);
34,35c33,34
<         auto q_end = std::queue<std::string>();
<         q_end.push(to);
---
>               auto q_end = std::queue<std::string>();
>               q_end.push(to);
37,38c36,37
<         auto visited_start = absl::flat_hash_set<std::string>();
<         auto visited_end = absl::flat_hash_set<std::string>();
---
>               auto visited_start = absl::flat_hash_set<std::string>();
>               auto visited_end = absl::flat_hash_set<std::string>();
40,41c39,40
<         unsigned long path_len_start = 0;
<         unsigned long path_len_end = 0;
---
>               unsigned long path_len_start = 0;
>               unsigned long path_len_end = 0;
45,53c44,52
<         while (!q_start.empty() && !q_end.empty()) {
<             // get the size of the queue
<             auto queue_size_start = q_start.size();
<             auto queue_size_end = q_end.size();
<
<             // BFS from the start word
<             for (unsigned long iter = 0; iter < queue_size_start; ++ iter){
<                 // pop
<                   auto current_word = q_start.front();
---
>               while (!q_start.empty() && !q_end.empty()) {
>                       // get the size of the queue
>                       auto queue_size_start = q_start.size();
>                       auto queue_size_end = q_end.size();
>
>                       // BFS from the start word
>                       for (unsigned long iter = 0; iter < queue_size_start; ++iter) {
>                               // pop
>                               auto current_word = q_start.front();
55c54
<                 visited_start.insert(current_word);
---
>                               visited_start.insert(current_word);
57c56
<                               for (unsigned long letter = 0; letter < current_word.length(); ++ letter){
---
>                               for (unsigned long letter = 0; letter < current_word.length(); ++letter) {
59c58
<                                       for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++ swapped_letter){
---
>                                       for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++swapped_letter) {
61c60
<                                               if(next_word == current_word){
---
>                                               if (next_word == current_word) {
64,65c63,64
<                                               if (!visited_end.contains(next_word)){
<                                                       if (!visited_start.contains(next_word) && lexicon.contains(next_word)){
---
>                                               if (!visited_end.contains(next_word)) {
>                                                       if (!visited_start.contains(next_word) && lexicon.contains(next_word)) {
69c68
<                                                               if (!map.contains(current_word)){
---
>                                                               if (!map.contains(current_word)) {
73c72,73
<                                                               } else{
---
>                                                               }
>                                                               else {
76c76,113
<                             }
---
>                                                       }
>                                               }
>                                               else {
>                                                       flag = 1;
>                                                       break;
>                                               }
>                                       }
>                                       if (flag == 1) {
>                                               break;
>                                       }
>                               }
>                               if (flag == 1) {
>                                       break;
>                               }
>                       }
>                       path_len_start++;
>
>                       if (flag == 1) {
>                               break;
>                       }
>
>                       // BFS from the end word
>                       for (unsigned long iter = 0; iter < queue_size_end; ++iter) {
>                               // pop
>                               auto current_word = q_end.front();
>                               q_end.pop();
>                               visited_end.insert(current_word);
>                               // for loop the word to swap every letter from 'a' to 'z'
>                               for (unsigned long letter = 0; letter < current_word.length(); ++letter) {
>                                       auto prev_word = current_word;
>                                       for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++swapped_letter) {
>                                               prev_word[letter] = swapped_letter;
>                                               if (prev_word == current_word) {
>                                                       continue;
>                                               }
>                                               if (!visited_start.contains(prev_word)) {
>                                                       if (!visited_end.contains(prev_word) && lexicon.contains(prev_word)) {
>                                                               q_end.push(prev_word);
78,150c115,152
<                         } else{
<                             flag = 1;
<                             break;
<                         }
<                     }
<                     if (flag == 1){
<                         break;
<                     }
<                 }
<                 if (flag == 1){
<                     break;
<                 }
<             }
<             path_len_start ++;
<
<             if (flag == 1){
<                 break;
<             }
<
<             // BFS from the end word
<             for (unsigned long iter = 0; iter < queue_size_end; ++ iter){
<                 // pop
<                 auto current_word = q_end.front();
<                 q_end.pop();
<                 visited_end.insert(current_word);
<                 // for loop the word to swap every letter from 'a' to 'z'
<                 for (unsigned long letter = 0; letter < current_word.length(); ++ letter){
<                     auto prev_word = current_word;
<                     for (char swapped_letter = 'a'; swapped_letter <= 'z'; ++ swapped_letter){
<                         prev_word[letter] = swapped_letter;
<                         if(prev_word == current_word){
<                             continue;
<                         }
<                         if (!visited_start.contains(prev_word)){
<                             if (!visited_end.contains(prev_word) && lexicon.contains(prev_word)){
<                                 q_end.push(prev_word);
<
<                                 // insert the current word into map[prev_word]
<                                 if (!map.contains(prev_word)){
<                                     absl::flat_hash_set<std::string> temp;
<                                     temp.insert(current_word);
<                                     map.insert({prev_word, temp});
<                                 } else{
<                                     map[prev_word].insert(current_word);
<                                 }
<                             }
<                         } else{
<                             flag = 1;
<                             break;
<                         }
<                     }
<                     if (flag == 1){
<                         break;
<                     }
<                 }
<                 if (flag == 1){
<                     break;
<                 }
<             }
<             path_len_end ++;
<
<             if (flag == 1){
<                 break;
<             }
<         }
<
<         // print an error message if no path is found
<         if (flag == 0){
<             std::cout << "No path is found between " << from << " and " << to << std::endl;
<             return result;
<         }
<
<         shortest_path_len = path_len_start + path_len_end - 1;
---
>                                                               // insert the current word into map[prev_word]
>                                                               if (!map.contains(prev_word)) {
>                                                                       absl::flat_hash_set<std::string> temp;
>                                                                       temp.insert(current_word);
>                                                                       map.insert({prev_word, temp});
>                                                               }
>                                                               else {
>                                                                       map[prev_word].insert(current_word);
>                                                               }
>                                                       }
>                                               }
>                                               else {
>                                                       flag = 1;
>                                                       break;
>                                               }
>                                       }
>                                       if (flag == 1) {
>                                               break;
>                                       }
>                               }
>                               if (flag == 1) {
>                                       break;
>                               }
>                       }
>                       path_len_end++;
>
>                       if (flag == 1) {
>                               break;
>                       }
>               }
>
>               // print an error message if no path is found
>               if (flag == 0) {
>                       std::cout << "No path is found between " << from << " and " << to << std::endl;
>                       return result;
>               }
>
>               shortest_path_len = path_len_start + path_len_end - 1;
152,153c154,155
<         // search for all the shortest paths by DFS
<         dfs(from, to, lexicon, map, result, path, shortest_path_len);
---
>               // search for all the shortest paths by DFS
>               dfs(from, to, lexicon, map, result, path, shortest_path_len);
155,156c157,158
<         // sort the ladders in alphabetical order
<         std::sort(result.begin(), result.end());
---
>               // sort the ladders in alphabetical order
>               std::sort(result.begin(), result.end());
158,159c160,161
<         return result;
<     }
---
>               return result;
>       }
162,182c164,183
< void dfs (std::string const& from,
<                                       std::string const& to,
<                     absl::flat_hash_set<std::string> const& lexicon,
<                     absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
<                     std::vector<std::vector<std::string>>& result,
<                     std::vector<std::string> path,
<                     unsigned long const& path_len)
<       {
<
<         if (path.size() != path_len + 1 ){
<             for (auto const& next_word: map[from]){
<                 auto next_path = path;
<                 next_path.push_back(next_word);
<                 dfs(next_word, to, lexicon, map, result, next_path, path_len);
<             }
<         } else{
<             if (path.back() == to){
<                 result.push_back(path);
<             }
<         }
<     }
---
> void dfs(std::string const& from,
>          std::string const& to,
>          absl::flat_hash_set<std::string> const& lexicon,
>          absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>& map,
>          std::vector<std::vector<std::string>>& result,
>          std::vector<std::string> path,
>          unsigned long const& path_len) {
>       if (path.size() != path_len + 1) {
>               for (auto const& next_word : map[from]) {
>                       auto next_path = path;
>                       next_path.push_back(next_word);
>                       dfs(next_word, to, lexicon, map, result, next_path, path_len);
>               }
>       }
>       else {
>               if (path.back() == to) {
>                       result.push_back(path);
>               }
>       }
> }
!!specialmark  (Linter)                                 0/0.75
========================================
======= Running Correctness ============
========================================
-- The CXX compiler identification is Clang 11.0.0
-- Check for working CXX compiler: /usr/bin/clang++-11
-- Check for working CXX compiler: /usr/bin/clang++-11 -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found /usr/bin/clang-tidy-11
-- Found ClangTidy: TRUE
-- Looking for C++ include pthread.h
-- Looking for C++ include pthread.h - found
-- Looking for pthread_create
-- Looking for pthread_create - not found
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - found
-- Found Threads: TRUE
-- Configuring done
-- Generating done
-- Build files have been written to: /tmp/tmp.EOSxgciBJj/build
[1/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment16.dir/word_ladder_test55_fragment16.cpp.o
[2/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment16.a
[3/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment13.dir/word_ladder_test55_fragment13.cpp.o
[4/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment13.a
[5/150] Building CXX object source/CMakeFiles/lexicon.dir/lexicon.cpp.o
[6/150] Linking CXX static library source/liblexicon.a
[7/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment12.dir/word_ladder_test55_fragment12.cpp.o
[8/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment12.a
[9/150] Building CXX object source/CMakeFiles/word_ladder.dir/word_ladder.cpp.o
[10/150] Linking CXX static library source/libword_ladder.a
[11/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment10.dir/word_ladder_test55_fragment10.cpp.o
[12/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment10.a
[13/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment8.dir/word_ladder_test55_fragment8.cpp.o
[14/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment8.a
[15/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment7.dir/word_ladder_test55_fragment7.cpp.o
[16/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment7.a
[17/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment9.dir/word_ladder_test55_fragment9.cpp.o
[18/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment9.a
[19/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment5.dir/word_ladder_test55_fragment5.cpp.o
[20/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment5.a
[21/150] Building CXX object test/CMakeFiles/test_main.dir/test_main.cpp.o
[22/150] Linking CXX static library test/libtest_main.a
[23/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test54.dir/word_ladder_test54.cpp.o
[24/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment11.dir/word_ladder_test55_fragment11.cpp.o
[25/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment11.a
[26/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test20.dir/word_ladder_test20.cpp.o
[27/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test30.dir/word_ladder_test30.cpp.o
[28/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test45.dir/word_ladder_test45.cpp.o
[29/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test24.dir/word_ladder_test24.cpp.o
[30/150] Linking CXX executable test/word_ladder/word_ladder_test54
[31/150] Linking CXX executable test/word_ladder/word_ladder_test20
[32/150] Linking CXX executable test/word_ladder/word_ladder_test30
[33/150] Linking CXX executable test/word_ladder/word_ladder_test45
[34/150] Linking CXX executable test/word_ladder/word_ladder_test24
[35/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test2.dir/word_ladder_test2.cpp.o
[36/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test25.dir/word_ladder_test25.cpp.o
[37/150] Linking CXX executable test/word_ladder/word_ladder_test2
[38/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test15.dir/word_ladder_test15.cpp.o
[39/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test18.dir/word_ladder_test18.cpp.o
[40/150] Linking CXX executable test/word_ladder/word_ladder_test25
[41/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test48.dir/word_ladder_test48.cpp.o
[42/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment14.dir/word_ladder_test55_fragment14.cpp.o
[43/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment14.a
[44/150] Linking CXX executable test/word_ladder/word_ladder_test15
[45/150] Linking CXX executable test/word_ladder/word_ladder_test18
[46/150] Linking CXX executable test/word_ladder/word_ladder_test48
[47/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test28.dir/word_ladder_test28.cpp.o
[48/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test26.dir/word_ladder_test26.cpp.o
[49/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test29.dir/word_ladder_test29.cpp.o
[50/150] Linking CXX executable test/word_ladder/word_ladder_test28
[51/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test16.dir/word_ladder_test16.cpp.o
[52/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test51.dir/word_ladder_test51.cpp.o
[53/150] Linking CXX executable test/word_ladder/word_ladder_test26
[54/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test21.dir/word_ladder_test21.cpp.o
[55/150] Linking CXX executable test/word_ladder/word_ladder_test29
[56/150] Linking CXX executable test/word_ladder/word_ladder_test16
[57/150] Linking CXX executable test/word_ladder/word_ladder_test51
[58/150] Linking CXX executable test/word_ladder/word_ladder_test21
[59/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test4.dir/word_ladder_test4.cpp.o
[60/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment2.dir/word_ladder_test55_fragment2.cpp.o
[61/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment2.a
[62/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test6.dir/word_ladder_test6.cpp.o
[63/150] Linking CXX executable test/word_ladder/word_ladder_test4
[64/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment15.dir/word_ladder_test55_fragment15.cpp.o
[65/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment15.a
[66/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test12.dir/word_ladder_test12.cpp.o
[67/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test5.dir/word_ladder_test5.cpp.o
[68/150] Linking CXX executable test/word_ladder/word_ladder_test6
[69/150] Linking CXX executable test/word_ladder/word_ladder_test12
[70/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test3.dir/word_ladder_test3.cpp.o
[71/150] Linking CXX executable test/word_ladder/word_ladder_test5
[72/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment4.dir/word_ladder_test55_fragment4.cpp.o
[73/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment4.a
[74/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test19.dir/word_ladder_test19.cpp.o
[75/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test22.dir/word_ladder_test22.cpp.o
[76/150] Linking CXX executable test/word_ladder/word_ladder_test3
[77/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test1.dir/word_ladder_test1.cpp.o
[78/150] Linking CXX executable test/word_ladder/word_ladder_test19
[79/150] Linking CXX executable test/word_ladder/word_ladder_test22
[80/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test42.dir/word_ladder_test42.cpp.o
[81/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test7.dir/word_ladder_test7.cpp.o
[82/150] Linking CXX executable test/word_ladder/word_ladder_test1
[83/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55.dir/word_ladder_test55.cpp.o
[84/150] Linking CXX executable test/word_ladder/word_ladder_test42
[85/150] Linking CXX executable test/word_ladder/word_ladder_test7
[86/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test36.dir/word_ladder_test36.cpp.o
[87/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test9.dir/word_ladder_test9.cpp.o
[88/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment0.dir/word_ladder_test55_fragment0.cpp.o
[89/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment0.a
[90/150] Linking CXX executable test/word_ladder/word_ladder_test9
[91/150] Linking CXX executable test/word_ladder/word_ladder_test36
[92/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test27.dir/word_ladder_test27.cpp.o
[93/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test11.dir/word_ladder_test11.cpp.o
[94/150] Linking CXX executable test/word_ladder/word_ladder_test27
[95/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test10.dir/word_ladder_test10.cpp.o
[96/150] Linking CXX executable test/word_ladder/word_ladder_test11
[97/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test23.dir/word_ladder_test23.cpp.o
[98/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test13.dir/word_ladder_test13.cpp.o
[99/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test41.dir/word_ladder_test41.cpp.o
[100/150] Linking CXX executable test/word_ladder/word_ladder_test10
[101/150] Linking CXX executable test/word_ladder/word_ladder_test41
[102/150] Linking CXX executable test/word_ladder/word_ladder_test23
[103/150] Linking CXX executable test/word_ladder/word_ladder_test13
[104/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test31.dir/word_ladder_test31.cpp.o
[105/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test49.dir/word_ladder_test49.cpp.o
[106/150] Linking CXX executable test/word_ladder/word_ladder_test31
[107/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test32.dir/word_ladder_test32.cpp.o
[108/150] Linking CXX executable test/word_ladder/word_ladder_test49
[109/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test34.dir/word_ladder_test34.cpp.o
[110/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test33.dir/word_ladder_test33.cpp.o
[111/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test17.dir/word_ladder_test17.cpp.o
[112/150] Linking CXX executable test/word_ladder/word_ladder_test32
[113/150] Linking CXX executable test/word_ladder/word_ladder_test34
[114/150] Linking CXX executable test/word_ladder/word_ladder_test33
[115/150] Linking CXX executable test/word_ladder/word_ladder_test17
[116/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test46.dir/word_ladder_test46.cpp.o
[117/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment6.dir/word_ladder_test55_fragment6.cpp.o
[118/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment6.a
[119/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test35.dir/word_ladder_test35.cpp.o
[120/150] Linking CXX executable test/word_ladder/word_ladder_test46
[121/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test37.dir/word_ladder_test37.cpp.o
[122/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test14.dir/word_ladder_test14.cpp.o
[123/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test39.dir/word_ladder_test39.cpp.o
[124/150] Linking CXX executable test/word_ladder/word_ladder_test35
[125/150] Linking CXX executable test/word_ladder/word_ladder_test37
[126/150] Linking CXX executable test/word_ladder/word_ladder_test14
[127/150] Linking CXX executable test/word_ladder/word_ladder_test39
[128/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test38.dir/word_ladder_test38.cpp.o
[129/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test8.dir/word_ladder_test8.cpp.o
[130/150] Linking CXX executable test/word_ladder/word_ladder_test38
[131/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test40.dir/word_ladder_test40.cpp.o
[132/150] Linking CXX executable test/word_ladder/word_ladder_test8
[133/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment3.dir/word_ladder_test55_fragment3.cpp.o
[134/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment3.a
[135/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test47.dir/word_ladder_test47.cpp.o
[136/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test43.dir/word_ladder_test43.cpp.o
[137/150] Linking CXX executable test/word_ladder/word_ladder_test40
[138/150] Linking CXX executable test/word_ladder/word_ladder_test43
[139/150] Linking CXX executable test/word_ladder/word_ladder_test47
[140/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test44.dir/word_ladder_test44.cpp.o
[141/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test50.dir/word_ladder_test50.cpp.o
[142/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test53.dir/word_ladder_test53.cpp.o
[143/150] Linking CXX executable test/word_ladder/word_ladder_test44
[144/150] Linking CXX executable test/word_ladder/word_ladder_test50
[145/150] Linking CXX executable test/word_ladder/word_ladder_test53
[146/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test52.dir/word_ladder_test52.cpp.o
[147/150] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test55_fragment1.dir/word_ladder_test55_fragment1.cpp.o
[148/150] Linking CXX static library test/word_ladder/libword_ladder_test55_fragment1.a
[149/150] Linking CXX executable test/word_ladder/word_ladder_test52
[150/150] Linking CXX executable test/word_ladder/word_ladder_test55
Errors while running CTest
Test project /tmp/tmp.EOSxgciBJj/build
      Start  1: test.word_ladder_test1
 1/55 Test  #1: test.word_ladder_test1 ...........   Passed    0.40 sec
      Start  2: test.word_ladder_test2
 2/55 Test  #2: test.word_ladder_test2 ...........   Passed    0.32 sec
      Start  3: test.word_ladder_test3
 3/55 Test  #3: test.word_ladder_test3 ...........   Passed    0.32 sec
      Start  4: test.word_ladder_test4
 4/55 Test  #4: test.word_ladder_test4 ...........   Passed    0.32 sec
      Start  5: test.word_ladder_test5
 5/55 Test  #5: test.word_ladder_test5 ...........   Passed    0.43 sec
      Start  6: test.word_ladder_test6
 6/55 Test  #6: test.word_ladder_test6 ...........   Passed    0.34 sec
      Start  7: test.word_ladder_test7
 7/55 Test  #7: test.word_ladder_test7 ...........   Passed    0.33 sec
      Start  8: test.word_ladder_test8
 8/55 Test  #8: test.word_ladder_test8 ...........   Passed    0.32 sec
      Start  9: test.word_ladder_test9
 9/55 Test  #9: test.word_ladder_test9 ...........   Passed    0.33 sec
      Start 10: test.word_ladder_test10
10/55 Test #10: test.word_ladder_test10 ..........   Passed    0.34 sec
      Start 11: test.word_ladder_test11
11/55 Test #11: test.word_ladder_test11 ..........   Passed    0.34 sec
      Start 12: test.word_ladder_test12
12/55 Test #12: test.word_ladder_test12 ..........   Passed    0.29 sec
      Start 13: test.word_ladder_test13
13/55 Test #13: test.word_ladder_test13 ..........   Passed    0.32 sec
      Start 14: test.word_ladder_test14
14/55 Test #14: test.word_ladder_test14 ..........   Passed    0.33 sec
      Start 15: test.word_ladder_test15
15/55 Test #15: test.word_ladder_test15 ..........   Passed    0.32 sec
      Start 16: test.word_ladder_test16
16/55 Test #16: test.word_ladder_test16 ..........   Passed    0.34 sec
      Start 17: test.word_ladder_test17
17/55 Test #17: test.word_ladder_test17 ..........   Passed    0.33 sec
      Start 18: test.word_ladder_test18
18/55 Test #18: test.word_ladder_test18 ..........   Passed    0.41 sec
      Start 19: test.word_ladder_test19
19/55 Test #19: test.word_ladder_test19 ..........   Passed    0.79 sec
      Start 20: test.word_ladder_test20
20/55 Test #20: test.word_ladder_test20 ..........   Passed    0.38 sec
      Start 21: test.word_ladder_test21
21/55 Test #21: test.word_ladder_test21 ..........   Passed    0.34 sec
      Start 22: test.word_ladder_test22
22/55 Test #22: test.word_ladder_test22 ..........   Passed    0.35 sec
      Start 23: test.word_ladder_test23
23/55 Test #23: test.word_ladder_test23 ..........   Passed    0.34 sec
      Start 24: test.word_ladder_test24
24/55 Test #24: test.word_ladder_test24 ..........   Passed    0.56 sec
      Start 25: test.word_ladder_test25
25/55 Test #25: test.word_ladder_test25 ..........   Passed    0.33 sec
      Start 26: test.word_ladder_test26
26/55 Test #26: test.word_ladder_test26 ..........   Passed    0.33 sec
      Start 27: test.word_ladder_test27
27/55 Test #27: test.word_ladder_test27 ..........   Passed    0.42 sec
      Start 28: test.word_ladder_test28
28/55 Test #28: test.word_ladder_test28 ..........   Passed    0.32 sec
      Start 29: test.word_ladder_test29
29/55 Test #29: test.word_ladder_test29 ..........   Passed    0.93 sec
      Start 30: test.word_ladder_test30
30/55 Test #30: test.word_ladder_test30 ..........   Passed    0.34 sec
      Start 31: test.word_ladder_test31
31/55 Test #31: test.word_ladder_test31 ..........   Passed    1.17 sec
      Start 32: test.word_ladder_test32
32/55 Test #32: test.word_ladder_test32 ..........   Passed    0.47 sec
      Start 33: test.word_ladder_test33
33/55 Test #33: test.word_ladder_test33 ..........   Passed    0.29 sec
      Start 34: test.word_ladder_test34
34/55 Test #34: test.word_ladder_test34 ..........   Passed    0.33 sec
      Start 35: test.word_ladder_test35
35/55 Test #35: test.word_ladder_test35 ..........   Passed    0.37 sec
      Start 36: test.word_ladder_test36
36/55 Test #36: test.word_ladder_test36 ..........   Passed    0.31 sec
      Start 37: test.word_ladder_test37
37/55 Test #37: test.word_ladder_test37 ..........   Passed    0.33 sec
      Start 38: test.word_ladder_test38
38/55 Test #38: test.word_ladder_test38 ..........***Timeout  18.02 sec

      Start 39: test.word_ladder_test39
39/55 Test #39: test.word_ladder_test39 ..........   Passed    0.26 sec
      Start 40: test.word_ladder_test40
40/55 Test #40: test.word_ladder_test40 ..........   Passed    0.30 sec
      Start 41: test.word_ladder_test41
41/55 Test #41: test.word_ladder_test41 ..........   Passed    0.27 sec
      Start 42: test.word_ladder_test42
42/55 Test #42: test.word_ladder_test42 ..........   Passed    0.47 sec
      Start 43: test.word_ladder_test43
43/55 Test #43: test.word_ladder_test43 ..........   Passed    0.86 sec
      Start 44: test.word_ladder_test44
44/55 Test #44: test.word_ladder_test44 ..........   Passed    0.25 sec
      Start 45: test.word_ladder_test45
45/55 Test #45: test.word_ladder_test45 ..........   Passed    0.27 sec
      Start 46: test.word_ladder_test46
46/55 Test #46: test.word_ladder_test46 ..........***Timeout  18.02 sec

      Start 47: test.word_ladder_test47
47/55 Test #47: test.word_ladder_test47 ..........   Passed    0.25 sec
      Start 48: test.word_ladder_test48
48/55 Test #48: test.word_ladder_test48 ..........   Passed    1.82 sec
      Start 49: test.word_ladder_test49
49/55 Test #49: test.word_ladder_test49 ..........   Passed    2.48 sec
      Start 50: test.word_ladder_test50
50/55 Test #50: test.word_ladder_test50 ..........   Passed    0.43 sec
      Start 51: test.word_ladder_test51
51/55 Test #51: test.word_ladder_test51 ..........   Passed    0.28 sec
      Start 52: test.word_ladder_test52
52/55 Test #52: test.word_ladder_test52 ..........***Timeout  18.00 sec

      Start 53: test.word_ladder_test53
53/55 Test #53: test.word_ladder_test53 ..........   Passed    2.80 sec
      Start 54: test.word_ladder_test54
54/55 Test #54: test.word_ladder_test54 ..........   Passed    0.27 sec
      Start 55: test.word_ladder_test55
55/55 Test #55: test.word_ladder_test55 ..........***Timeout  18.02 sec


93% tests passed, 4 tests failed out of 55

Total Test time (real) =  98.18 sec

The following tests FAILED:
         38 - test.word_ladder_test38 (Timeout)
         46 - test.word_ladder_test46 (Timeout)
         52 - test.word_ladder_test52 (Timeout)
         55 - test.word_ladder_test55 (Timeout)

Marking feedback here
!!specialmark  (Correctness)                            6.954545454545454/7.5
========================================
======= Running Own Tests ==============
========================================
Output running of own tests here
-- The CXX compiler identification is Clang 11.0.0
-- Check for working CXX compiler: /usr/bin/clang++-11
-- Check for working CXX compiler: /usr/bin/clang++-11 -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found /usr/bin/clang-tidy-11
-- Found ClangTidy: TRUE
-- Looking for C++ include pthread.h
-- Looking for C++ include pthread.h - found
-- Looking for pthread_create
-- Looking for pthread_create - not found
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - found
-- Found Threads: TRUE
-- Configuring done
-- Generating done
-- Build files have been written to: /tmp/tmp.ahNKRK2KzV/build-owntests
[1/12] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test_benchmark.dir/word_ladder_test_benchmark.cpp.o
[2/12] Building CXX object test/word_ladder/CMakeFiles/word_ladder_test1.dir/word_ladder_test1.cpp.o
[3/12] Building CXX object test/word_ladder/CMakeFiles/word_ladder_tests.dir/tests.cpp.o
[4/12] Building CXX object source/CMakeFiles/lexicon.dir/lexicon.cpp.o
[5/12] Linking CXX static library source/liblexicon.a
[6/12] Building CXX object source/CMakeFiles/word_ladder.dir/word_ladder.cpp.o
[7/12] Linking CXX static library source/libword_ladder.a
[8/12] Building CXX object test/CMakeFiles/test_main.dir/test_main.cpp.o
[9/12] Linking CXX static library test/libtest_main.a
[10/12] Linking CXX executable test/word_ladder/word_ladder_test_benchmark
[11/12] Linking CXX executable test/word_ladder/word_ladder_test1
[12/12] Linking CXX executable test/word_ladder/word_ladder_tests
Test project /tmp/tmp.ahNKRK2KzV/build-owntests
    Start 1: test.word_ladder_test1
    Start 2: test.word_ladder_test_benchmark
    Start 3: test.word_ladder_tests
1/3 Test #1: test.word_ladder_test1 ............   Passed    0.28 sec
2/3 Test #3: test.word_ladder_tests ............   Passed    0.98 sec
3/3 Test #2: test.word_ladder_test_benchmark ...***Timeout  20.02 sec


67% tests passed, 1 tests failed out of 3

Total Test time (real) =  20.02 sec

The following tests FAILED:
          2 - test.word_ladder_test_benchmark (Timeout)
Errors while running CTest
!!specialmark  (Running your own tests)                 0/0

!!marktab       **  MARKER'S  ASSESSMENT  **

                            testing   ..  (3.75)        2.5
 ^
 + ============================================================================================== +
 + You missed explicitly checking that ladder rungs are indeed one hop away. Also, try to use as  +
 + little run-time verifiable code as possible                                                    +
 + ============================================================================================== +

                            bestpractice  (3)   1.25
 ^
+ ================================================================================================== +
+ Very much a C program with C++ syntax. Please see my comments for some places you can improve and  +
+ revisit the lecture slides for C++-style practices.                                                +
+ ================================================================================================== +

!!finalmark     **  FINAL  ASSIGNMENT  MARK:    10.7045/15

5180847 Li, Patrick                             8543   COMPAS COMPCS





Marked by z5061640 on Sat Jul  4 11:54:52 2020